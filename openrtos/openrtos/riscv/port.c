/*
 * FreeRTOS Kernel V10.1.1
 * Copyright (C) 2018 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 * http://www.FreeRTOS.org
 * http://aws.amazon.com/freertos
 *
 * 1 tab == 4 spaces!
 */

/*-----------------------------------------------------------
 * Implementation of functions defined in portable.h for the RISC-V port.
 *----------------------------------------------------------*/

/* Scheduler includes. */
#include "FreeRTOS.h"
#include "task.h"
#include "portmacro.h"
#include "ite/ith.h"

/* Macros for enable/disable global interrupt (mstatus.mie) */
#define portMIE_DISABLE()    __asm volatile( "csrc mstatus, 0x8" )
#define portMIE_ENABLE()     __asm volatile( "csrs mstatus, 0x8" )
#define portMIE_SAVE()       prvMieSave()
#define portMIE_RESTORE( x ) prvMieRestore( x )


/* A variable is used to keep track of the critical section nesting.  This
variable has to be stored as part of the task context and must be initialised to
a non zero value to ensure interrupts don't inadvertently become unmasked before
the scheduler starts.  As it is stored as part of the task context it will
automatically be set to 0 when the first task is started. */
static UBaseType_t uxCriticalNesting = 0xaaaaaaaa;

/* Contains context when starting scheduler, save all 31 registers */
#ifdef __gracefulExit
BaseType_t xStartContext[31] = {0};
#endif

#if( configUSE_TICKLESS_IDLE == 1 )
	/* Flag set from the timer interrupt to allow the sleep processing to know if
	sleep mode was exited because of a tick interrupt, or an interrupt
	generated by something else. */
	static volatile BaseType_t xTickFlag = pdFALSE;
#endif /* configUSE_TICKLESS_IDLE */

/*
 * Handler for timer interrupt
 */
void vPortSysTickHandler( void* arg ) __attribute__((naked));

/*
 * Setup the timer to generate the tick interrupts.
 */
void vPortSetupTimer( void );

/*
 * Used to catch tasks that attempt to return from their implementing function.
 */
static void prvTaskExitError( void );

/*-----------------------------------------------------------*/

__attribute__((always_inline))
static inline UBaseType_t prvMieSave()
{
UBaseType_t uxSavedStatusValue;

	__asm volatile( "csrrc %0, mstatus, 0x8":"=r"( uxSavedStatusValue ) );
	return uxSavedStatusValue;
}
/*-----------------------------------------------------------*/

__attribute__((always_inline))
static inline void prvMieRestore( UBaseType_t uxSavedStatusValue )
{
	__asm volatile( "csrw mstatus, %0"::"r"( uxSavedStatusValue ) );
}
/*-----------------------------------------------------------*/

/* prvReadMtime(): Read machine timer register.
Note: Always use this API to access mtime */
__attribute__((always_inline))
static inline uint32_t prvReadMtime( void )
{
    return ithTimerGetCounter( portTIMER );
}
/*-----------------------------------------------------------*/

/* prvWriteMtimeCmp(ullNewMtimeCmp): Write machine timer compare register.
Note: Use this API to access register if timer interrupt is enabled. */
__attribute__((always_inline))
static inline void prvWriteMtimeCmp( uint32_t ullNewMtimeCmp )
{
    ithTimerSetMatch(portTIMER, ullNewMtimeCmp);
}
/*-----------------------------------------------------------*/

/* Sets the next timer interrupt */
static void prvSetNextTimerInterrupt(void)
{
	#if( configUSE_TICKLESS_IDLE == 1 )
    if (xTickFlag == pdFALSE)
    {
        ithTimerSetMatch(portTIMER, configCPU_CLOCK_HZ / configTICK_RATE_HZ);
    }
	#endif /* configUSE_TICKLESS_IDLE */

    ithTimerClearIntr(portTIMER);
}
/*-----------------------------------------------------------*/

/* Sets and enable the timer interrupt */
void vPortSetupTimer(void)
{
    /* Stop the tick timer... */
    ithTimerDisable(portTIMER);

    /* Start with tick timer interrupts disabled... */
    ithIntrDisableIrq(portTIMER_INTR);

    /* Clear any pending tick timer interrupts... */
    ithTimerClearIntr(portTIMER);
    ithIntrClearIrq(portTIMER_INTR);

    /* Store interrupt handler function address in tick timer vector register... */
    ithIntrRegisterHandlerIrq(portTIMER_INTR, vPortSysTickHandler, NULL);

    /* Tick timer interrupt level-sensitive */
    ithIntrSetTriggerModeIrq(portTIMER_INTR, ITH_INTR_EDGE);
    ithTimerCtrlEnable(portTIMER, ITH_TIMER_UPCOUNT);
    ithTimerCtrlEnable(portTIMER, ITH_TIMER_PERIODIC);

    /* Enable the tick timer interrupt... */
    ithIntrEnableIrq(portTIMER_INTR);

    /* Calculate timer compare value to achieve the desired tick rate... */
    ithTimerSetCounter(portTIMER, 0);
    ithTimerSetMatch(portTIMER, configCPU_CLOCK_HZ / configTICK_RATE_HZ);

    /* Start tick timer... */
    ithTimerEnable(portTIMER);

	/* Enable timer interupt */
	__asm volatile("csrs mie,%0"::"r"(0x80));
}
/*-----------------------------------------------------------*/

void prvTaskExitError( void )
{
	/* A function that implements a task must not exit or attempt to return to
	its caller as there is nothing to return to.  If a task wants to exit it
	should instead call vTaskDelete( NULL ).

	Artificially force an assert() to be triggered if configASSERT() is
	defined, then stop here so application writers can catch the error. */
	configASSERT( uxCriticalNesting == ~0UL );
	portDISABLE_INTERRUPTS();
	for( ;; );
}
/*-----------------------------------------------------------*/

/* Clear current interrupt mask and set given mask */
void vPortClearInterruptMask(int mask)
{
	__asm volatile("csrw mie, %0"::"r"(mask));
}
/*-----------------------------------------------------------*/

/* Set interrupt mask and return current interrupt enable register */
int vPortSetInterruptMask(void)
{
	int ret;
	__asm volatile("csrr %0,mie":"=r"(ret));
	__asm volatile("csrc mie,%0"::"i"(7));
	return ret;
}
/*-----------------------------------------------------------*/


/*
 * See header file for description.
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
	/* Simulate the stack frame as it would be created by a context switch
	interrupt. */
	register int *gp asm("x3");
#ifdef __riscv_flen
	pxTopOfStack -= ((32 * (__riscv_flen / 8)) / sizeof(StackType_t));
#endif
	pxTopOfStack--;
	*pxTopOfStack = (portSTACK_TYPE)pxCode;			/* Start address */
	pxTopOfStack -= 22;
	*pxTopOfStack = (portSTACK_TYPE)pvParameters;	/* Register a0 */
	pxTopOfStack -= 6;
	*pxTopOfStack = (portSTACK_TYPE)gp; /* Register global pointer */
	pxTopOfStack -= 3;
	*pxTopOfStack = (portSTACK_TYPE)prvTaskExitError; /* Register ra */

	return pxTopOfStack;
}
/*-----------------------------------------------------------*/

void vPortSysTickHandler( void* arg )
{
	prvSetNextTimerInterrupt();

	/* Increment the RTOS tick. */
	if( xTaskIncrementTick() != pdFALSE )
	{
		vTaskSwitchContext();
	}

	#if( configUSE_TICKLESS_IDLE == 1 )
		xTickFlag = pdTRUE;
	#endif /* configUSE_TICKLESS_IDLE */
}
/*-----------------------------------------------------------*/

#if( configUSE_TICKLESS_IDLE == 1 )
	/* Stop mtime interrupt by setting timer compare register to maximum value.
	Again, We assume mtime overflow doesn't occur, like prvWriteMtimeCmp().

	This function backups previous value of timer compare register and
	returning it. */
	__attribute__((always_inline))
	static inline uint32_t prvStopMtime( void )
	{
	uint32_t ullSavedMtimeCmp;
	UBaseType_t uxSavedStatus;

		uxSavedStatus = portMIE_SAVE();
		{
		  ithTimerDisable(portTIMER);
			ullSavedMtimeCmp = configCPU_CLOCK_HZ / configTICK_RATE_HZ - ithTimerGetCounter(portTIMER);
			if (ullSavedMtimeCmp > configCPU_CLOCK_HZ / configTICK_RATE_HZ)
			    ullSavedMtimeCmp = 0;
		}
		portMIE_RESTORE( uxSavedStatus );
		return ullSavedMtimeCmp;
	}

	__attribute__((weak)) void vPortSuppressTicksAndSleep( TickType_t xExpectedIdleTime )
	{
	/* The number of Timer's cycle that make up one tick period. */
	#define portUL_TIMER_COUNTS_FOR_ONE_TICK ( (uint32_t)( configCPU_CLOCK_HZ / configTICK_RATE_HZ ) )

	/* The maximum number of tick periods that can be suppressed is limited by
	the resolution of the Timer */
	#define portULL_MAXIMUM_POSSIBLE_SUPPRESSED_TICKS ( (1ULL << 30) / portUL_TIMER_COUNTS_FOR_ONE_TICK )

	/* Unit: cycle */
	uint32_t ulNextTickTime, ulWakeUpTime, ulCurrentTime;

	/* Unit: tick */
	TickType_t xCompleteTickPeriods, xTickPeriodsBeforeWakeup, xModifiableIdleTime;

		/* Make sure the Timer reload value does not overflow the Timer
		resolution. To avoid integer overflow when assigning maximum tick
		periods to TickType_t, check portMAX_DELAY first.
		p.s. xExpectedIdleTime is always lower than portMAX_DELAY */
		if( portMAX_DELAY > portULL_MAXIMUM_POSSIBLE_SUPPRESSED_TICKS )
		{
			/* if portMAX_DELAY > portULL_MAXIMUM_POSSIBLE_SUPPRESSED_TICKS, then the
			size of TickType_t is larger than or equal to maximum tick period */
			if( xExpectedIdleTime > portULL_MAXIMUM_POSSIBLE_SUPPRESSED_TICKS )
			{
				xExpectedIdleTime = portULL_MAXIMUM_POSSIBLE_SUPPRESSED_TICKS;
			}
		}

		/* Stop mtime interrupt */
		ulNextTickTime = prvStopMtime();

		/* Calculate the mtimecmp value to wait xExpectedIdleTime tick periods.
		Wakeup time is at ( xExpectedIdleTime - 1 ) ticks after next tick. */
		ulWakeUpTime = ulNextTickTime + ( ( xExpectedIdleTime - 1 ) * portUL_TIMER_COUNTS_FOR_ONE_TICK );

		portMIE_DISABLE();
		if( eTaskConfirmSleepModeStatus() == eAbortSleep )
		{
			/* Set reload value and restart timer */
			prvWriteMtimeCmp( configCPU_CLOCK_HZ / configTICK_RATE_HZ );

			/* Re-enable interrupts. */
			portMIE_ENABLE();
		}
		else
		{
			/* The tick flag is set to false before sleeping. If it is true when
			sleep mode is exited then sleep mode was probably exited because the
			tick was suppressed for the entire xExpectedIdleTime period. */
			xTickFlag = pdFALSE;

			/* Set reload value and restart timer */
			prvWriteMtimeCmp( ulWakeUpTime );

			/* Sleep until something happens.  configPRE_SLEEP_PROCESSING() can
			set its parameter to 0 to indicate that its implementation contains
			its own wait for interrupt or wait for event instruction, and so wfi
			should not be executed again.  However, the original expected idle
			time variable must remain unmodified, so a copy is taken. */
			xModifiableIdleTime = xExpectedIdleTime;
			configPRE_SLEEP_PROCESSING( xModifiableIdleTime );
			if( xModifiableIdleTime > 0 )
			{
				__asm volatile( "wfi" );
			}
			configPOST_SLEEP_PROCESSING( xExpectedIdleTime );

			/* Re-enable interrupts to allow the interrupt that brought the MCU
			out of sleep mode to execute immediately. */
			portMIE_ENABLE();

			/* Disable interrupts again to avoid timer ISR runs after checking
			xTickFlag. */
			portMIE_DISABLE();

			if( xTickFlag == pdTRUE )
			{
				/* As the pending tick will be processed as soon as this
				function exits, the tick value maintained by the tick is stepped
				forward by one less than the time spent waiting. */
				xCompleteTickPeriods = xExpectedIdleTime - 1;

				/* Note: mtimecmp is correct in this condition, so we doesn't
				need to access it */
			}
			else
			{
				ulCurrentTime = prvReadMtime();

				if( ulCurrentTime >= ulWakeUpTime )
				{
					/* Tick interrupt is pending because it occurs after
					disabling MIE. The tick value is stepped forward by
					the time spent waiting. */
					xCompleteTickPeriods = xExpectedIdleTime;
				}
				else
				{
					/* Something other than the tick interrupt ended the sleep.
					Work out how long the sleep lasted rounded to complete tick
					periods. */

					/* Round up the tick period before wakeup to the Tick unit */
					xTickPeriodsBeforeWakeup = ( ulWakeUpTime - ulCurrentTime - 1 ) / portUL_TIMER_COUNTS_FOR_ONE_TICK + 1;
					xCompleteTickPeriods = xExpectedIdleTime - xTickPeriodsBeforeWakeup;
				}

				prvWriteMtimeCmp( ulNextTickTime + ( (xCompleteTickPeriods) * portUL_TIMER_COUNTS_FOR_ONE_TICK ) );
			}

			vTaskStepTick( xCompleteTickPeriods );

			/* Exit with interrpts enabled. */
			portMIE_ENABLE();
		}
	}
#endif /* configUSE_TICKLESS_IDLE */

extern void itpErrorStackOverflow(void) __attribute__ ((naked));

void vApplicationStackOverflowHook( TaskHandle_t *pxTask, signed char *pcTaskName )
{
    /* Check pcTaskName for the name of the offending task, or pxCurrentTCB
    if pcTaskName has itself been corrupted. */
    ( void ) pxTask;
    ( void ) pcTaskName;
    itpErrorStackOverflow();
    for( ;; );
}
/*-----------------------------------------------------------*/
/*
 * malloc, realloc and free are meant to be called through respectively
 * pvPortMalloc, pvPortRealloc and vPortFree.
 * The latter functions call the former ones from within sections where tasks
 * are suspended, so the latter functions are task-safe. __malloc_lock and
 * __malloc_unlock use the same mechanism to also keep the former functions
 * task-safe as they may be called directly from Newlib's functions.
 * However, all these functions are interrupt-unsafe and SHALL THEREFORE NOT BE
 * CALLED FROM WITHIN AN INTERRUPT, because __malloc_lock and __malloc_unlock do
 * not call portENTER_CRITICAL and portEXIT_CRITICAL in order not to disable
 * interrupts during memory allocation management as this may be a very time-
 * consuming process.
 */

/*
 * Lock routine called by Newlib on malloc / realloc / free entry to guarantee a
 * safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_lock(struct _reent *ptr)
{
    ithEnterCritical();
    //vTaskSuspendAll();
}
/*-----------------------------------------------------------*/

/*
 * Unlock routine called by Newlib on malloc / realloc / free exit to guarantee
 * a safe section as memory allocation management uses global data.
 * See the aforementioned details.
 */
void __malloc_unlock(struct _reent *ptr)
{
    ithExitCritical();
    //xTaskResumeAll();
}
/*-----------------------------------------------------------*/

void vConfigureTimerForRunTimeStats( void )
{
}
/*-----------------------------------------------------------*/
